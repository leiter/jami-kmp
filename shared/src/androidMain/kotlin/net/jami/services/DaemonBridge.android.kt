/*
 *  Copyright (C) 2004-2025 Savoir-faire Linux Inc.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program. If not, see <https://www.gnu.org/licenses/>.
 */
package net.jami.services

import net.jami.daemon.Blob
import net.jami.daemon.Callback
import net.jami.daemon.ConfigurationCallback
import net.jami.daemon.ConversationCallback
import net.jami.daemon.DataTransferCallback
import net.jami.daemon.IntegerMap
import net.jami.daemon.JamiService
import net.jami.daemon.PresenceCallback
import net.jami.daemon.StringMap
import net.jami.daemon.StringVect
import net.jami.daemon.VectMap
import net.jami.daemon.VideoCallback
import net.jami.daemon.SwarmMessage as SwigSwarmMessage
import net.jami.model.MediaAttribute
import net.jami.model.SwarmMessage
import net.jami.utils.Log

/**
 * Android implementation of DaemonBridge using SWIG-generated JNI bindings.
 *
 * This implementation wraps the JamiService class generated by SWIG from
 * jami-daemon/bin/jni/jni_interface.i
 *
 * ## Callback Flow
 *
 * C++ Daemon → SWIG Director Classes → DaemonBridge → DaemonCallbacks interface
 */
actual class DaemonBridge actual constructor() {
    private var isInitialized = false
    private var callbacks: DaemonCallbacks? = null

    // Callback implementations - must keep references to prevent GC
    private var configurationCallback: ConfigurationCallback? = null
    private var callCallback: Callback? = null
    private var presenceCallback: PresenceCallback? = null
    private var videoCallback: VideoCallback? = null
    private var dataTransferCallback: DataTransferCallback? = null
    private var conversationCallback: ConversationCallback? = null

    companion object {
        private const val TAG = "DaemonBridge"
        private var isNativeLoaded = false

        init {
            try {
                System.loadLibrary("jami")
                isNativeLoaded = true
                Log.i(TAG, "Native library 'jami' loaded successfully")
            } catch (e: UnsatisfiedLinkError) {
                Log.e(TAG, "Failed to load native library 'jami': ${e.message}")
            }
        }
    }

    actual fun init(callbacks: DaemonCallbacks): Boolean {
        if (!isNativeLoaded) {
            Log.e(TAG, "Cannot initialize - native library not loaded")
            return false
        }

        this.callbacks = callbacks

        try {
            // Create callback implementations that forward to DaemonCallbacks
            configurationCallback = createConfigurationCallback(callbacks)
            callCallback = createCallCallback(callbacks)
            presenceCallback = createPresenceCallback(callbacks)
            videoCallback = createVideoCallback()
            dataTransferCallback = createDataTransferCallback(callbacks)
            conversationCallback = createConversationCallback(callbacks)

            // Initialize daemon with all callbacks
            JamiService.init(
                configurationCallback,
                callCallback,
                presenceCallback,
                dataTransferCallback,
                videoCallback,
                conversationCallback
            )

            isInitialized = true
            Log.i(TAG, "DaemonBridge initialized successfully")
            return true

        } catch (e: Exception) {
            Log.e(TAG, "Failed to initialize daemon: ${e.message}")
            return false
        }
    }

    actual fun start(): Boolean {
        if (!isInitialized) {
            Log.w(TAG, "Cannot start - daemon not initialized")
            return false
        }
        // JamiService starts automatically during init()
        Log.i(TAG, "Daemon started")
        return true
    }

    actual fun stop() {
        if (isInitialized) {
            try {
                JamiService.fini()
            } catch (e: Exception) {
                Log.e(TAG, "Error stopping daemon: ${e.message}")
            }
            isInitialized = false
            Log.i(TAG, "Daemon stopped")
        }
    }

    actual fun isRunning(): Boolean = isInitialized

    // ==================== Account Operations ====================

    actual fun addAccount(details: Map<String, String>): String {
        return JamiService.addAccount(StringMap.toSwig(details))
    }

    actual fun removeAccount(accountId: String) {
        JamiService.removeAccount(accountId)
    }

    actual fun getAccountDetails(accountId: String): Map<String, String> {
        return JamiService.getAccountDetails(accountId).toNative()
    }

    actual fun setAccountDetails(accountId: String, details: Map<String, String>) {
        JamiService.setAccountDetails(accountId, StringMap.toSwig(details))
    }

    actual fun getAccountList(): List<String> {
        return JamiService.getAccountList().toList()
    }

    actual fun setAccountActive(accountId: String, active: Boolean) {
        JamiService.setAccountActive(accountId, active)
    }

    actual fun getAccountTemplate(accountType: String): Map<String, String> {
        return JamiService.getAccountTemplate(accountType).toNative()
    }

    actual fun getVolatileAccountDetails(accountId: String): Map<String, String> {
        return JamiService.getVolatileAccountDetails(accountId).toNative()
    }

    actual fun sendRegister(accountId: String, enable: Boolean) {
        JamiService.sendRegister(accountId, enable)
    }

    actual fun setAccountsOrder(order: String) {
        JamiService.setAccountsOrder(order)
    }

    actual fun changeAccountPassword(accountId: String, oldPassword: String, newPassword: String): Boolean {
        return JamiService.changeAccountPassword(accountId, oldPassword, newPassword)
    }

    actual fun exportToFile(accountId: String, path: String, scheme: String, password: String): Boolean {
        return JamiService.exportToFile(accountId, path, scheme, password)
    }

    // ==================== Credentials ====================

    actual fun getCredentials(accountId: String): List<Map<String, String>> {
        return JamiService.getCredentials(accountId).toNative()
    }

    actual fun setCredentials(accountId: String, credentials: List<Map<String, String>>) {
        JamiService.setCredentials(accountId, credentials.toSwigVectMap())
    }

    // ==================== Device Management ====================

    actual fun getKnownRingDevices(accountId: String): Map<String, String> {
        return JamiService.getKnownRingDevices(accountId).toNative()
    }

    actual fun revokeDevice(accountId: String, deviceId: String, scheme: String, password: String) {
        JamiService.revokeDevice(accountId, deviceId, scheme, password)
    }

    actual fun setDeviceName(accountId: String, deviceName: String) {
        val details = JamiService.getAccountDetails(accountId)
        details["Account.deviceName"] = deviceName
        JamiService.setAccountDetails(accountId, details)
    }

    // ==================== Profile ====================

    actual fun updateProfile(accountId: String, displayName: String, avatar: String, fileType: String, flag: Int) {
        JamiService.updateProfile(accountId, displayName, avatar, fileType, flag)
    }

    // ==================== Call Operations ====================

    actual fun placeCall(accountId: String, uri: String, mediaList: List<MediaAttribute>): String {
        val swigMedia = mediaList.toSwigVectMap()
        return JamiService.placeCallWithMedia(accountId, uri, swigMedia)
    }

    actual fun accept(accountId: String, callId: String, mediaList: List<MediaAttribute>) {
        JamiService.acceptWithMedia(accountId, callId, mediaList.toSwigVectMap())
    }

    actual fun hangUp(accountId: String, callId: String) {
        JamiService.hangUp(accountId, callId)
    }

    actual fun hold(accountId: String, callId: String) {
        JamiService.hold(accountId, callId)
    }

    actual fun unhold(accountId: String, callId: String) {
        JamiService.unhold(accountId, callId)
    }

    actual fun muteLocalMedia(accountId: String, callId: String, mediaType: String, mute: Boolean) {
        JamiService.muteLocalMedia(accountId, callId, mediaType, mute)
    }

    // ==================== Conversation Operations ====================

    actual fun getConversations(accountId: String): List<String> {
        return JamiService.getConversations(accountId).toList()
    }

    actual fun startConversation(accountId: String): String {
        return JamiService.startConversation(accountId)
    }

    actual fun sendMessage(accountId: String, conversationId: String, message: String, replyTo: String, flag: Int) {
        JamiService.sendMessage(accountId, conversationId, message, replyTo, flag)
    }

    actual fun loadConversation(accountId: String, conversationId: String, fromMessage: String, size: Int) {
        JamiService.loadConversation(accountId, conversationId, fromMessage, size.toLong())
    }

    actual fun getConversationMembers(accountId: String, conversationId: String): List<Map<String, String>> {
        return JamiService.getConversationMembers(accountId, conversationId).toNative()
    }

    actual fun getConversationInfo(accountId: String, conversationId: String): Map<String, String> {
        return JamiService.conversationInfos(accountId, conversationId).toNativeFromUtf8()
    }

    actual fun removeConversation(accountId: String, conversationId: String) {
        JamiService.removeConversation(accountId, conversationId)
    }

    actual fun addConversationMember(accountId: String, conversationId: String, uri: String) {
        JamiService.addConversationMember(accountId, conversationId, uri)
    }

    actual fun removeConversationMember(accountId: String, conversationId: String, uri: String) {
        JamiService.removeConversationMember(accountId, conversationId, uri)
    }

    actual fun updateConversationInfo(accountId: String, conversationId: String, info: Map<String, String>) {
        JamiService.updateConversationInfos(accountId, conversationId, StringMap.toSwig(info))
    }

    actual fun getConversationPreferences(accountId: String, conversationId: String): Map<String, String> {
        return JamiService.getConversationPreferences(accountId, conversationId).toNative()
    }

    actual fun setConversationPreferences(accountId: String, conversationId: String, prefs: Map<String, String>) {
        JamiService.setConversationPreferences(accountId, conversationId, StringMap.toSwig(prefs))
    }

    actual fun setMessageDisplayed(accountId: String, conversationUri: String, messageId: String, status: Int) {
        JamiService.setMessageDisplayed(accountId, conversationUri, messageId, status)
    }

    actual fun getActiveCalls(accountId: String, conversationId: String): List<Map<String, String>> {
        return JamiService.getActiveCalls(accountId, conversationId).toNative()
    }

    // ==================== Conversation Requests ====================

    actual fun getConversationRequests(accountId: String): List<Map<String, String>> {
        return JamiService.getConversationRequests(accountId).map { it.toNativeFromUtf8() }
    }

    actual fun acceptConversationRequest(accountId: String, conversationId: String) {
        JamiService.acceptConversationRequest(accountId, conversationId)
    }

    actual fun declineConversationRequest(accountId: String, conversationId: String) {
        JamiService.declineConversationRequest(accountId, conversationId)
    }

    // ==================== Trust Requests ====================

    actual fun getTrustRequests(accountId: String): List<Map<String, String>> {
        return JamiService.getTrustRequests(accountId).toNative()
    }

    actual fun acceptTrustRequest(accountId: String, uri: String) {
        JamiService.acceptTrustRequest(accountId, uri)
    }

    actual fun discardTrustRequest(accountId: String, uri: String) {
        JamiService.discardTrustRequest(accountId, uri)
    }

    actual fun sendTrustRequest(accountId: String, uri: String, payload: ByteArray) {
        val blob = Blob(payload)
        JamiService.sendTrustRequest(accountId, uri, blob)
    }

    // ==================== Contact Operations ====================

    actual fun addContact(accountId: String, uri: String) {
        JamiService.addContact(accountId, uri)
    }

    actual fun removeContact(accountId: String, uri: String, ban: Boolean) {
        JamiService.removeContact(accountId, uri, ban)
    }

    actual fun getContacts(accountId: String): List<Map<String, String>> {
        return JamiService.getContacts(accountId).toNative()
    }

    actual fun getContactDetails(accountId: String, uri: String): Map<String, String> {
        return JamiService.getContactDetails(accountId, uri).toNative()
    }

    actual fun subscribeBuddy(accountId: String, uri: String, subscribe: Boolean) {
        JamiService.subscribeBuddy(accountId, uri, subscribe)
    }

    // ==================== Name Lookup ====================

    actual fun lookupName(accountId: String, nameServiceUrl: String, name: String): Boolean {
        return JamiService.lookupName(accountId, nameServiceUrl, name)
    }

    actual fun lookupAddress(accountId: String, nameServiceUrl: String, address: String): Boolean {
        return JamiService.lookupAddress(accountId, nameServiceUrl, address)
    }

    actual fun registerName(accountId: String, name: String, scheme: String, password: String): Boolean {
        return JamiService.registerName(accountId, name, scheme, password)
    }

    actual fun searchUser(accountId: String, query: String): Boolean {
        return JamiService.searchUser(accountId, query)
    }

    // ==================== Messaging ====================

    actual fun sendTextMessage(accountId: String, callIdOrUri: String, message: String) {
        val payload = StringMap()
        payload["text/plain"] = message
        JamiService.sendAccountTextMessage(accountId, callIdOrUri, payload, 0)
    }

    actual fun setIsComposing(accountId: String, uri: String, isComposing: Boolean) {
        JamiService.setIsComposing(accountId, uri, isComposing)
    }

    actual fun cancelMessage(accountId: String, messageId: Long): Boolean {
        return JamiService.cancelMessage(accountId, messageId)
    }

    // ==================== File Transfer ====================

    actual fun sendFile(accountId: String, conversationId: String, filePath: String, displayName: String, parent: String) {
        JamiService.sendFile(accountId, conversationId, filePath, displayName, parent)
    }

    actual fun downloadFile(accountId: String, conversationId: String, interactionId: String, fileId: String, path: String) {
        JamiService.downloadFile(accountId, conversationId, interactionId, fileId, path)
    }

    actual fun cancelDataTransfer(accountId: String, conversationId: String, fileId: String) {
        JamiService.cancelDataTransfer(accountId, conversationId, fileId)
    }

    actual fun fileTransferInfo(accountId: String, conversationId: String, fileId: String): FileTransferInfo? {
        val paths = arrayOfNulls<String>(1)
        val totalSize = LongArray(1)
        val bytesProgress = LongArray(1)
        JamiService.fileTransferInfo(accountId, conversationId, fileId, paths, totalSize, bytesProgress)
        val path = paths[0] ?: return null
        return FileTransferInfo(path, totalSize[0], bytesProgress[0])
    }

    // ==================== Codec Operations ====================

    actual fun getCodecList(): List<Long> {
        return JamiService.getCodecList().map { it.toLong() }
    }

    actual fun getActiveCodecList(accountId: String): List<Long> {
        return JamiService.getActiveCodecList(accountId).map { it.toLong() }
    }

    actual fun setActiveCodecList(accountId: String, codecList: List<Long>) {
        val uintVect = net.jami.daemon.UintVect()
        codecList.forEach { uintVect.add(it) }
        JamiService.setActiveCodecList(accountId, uintVect)
    }

    actual fun getCodecDetails(accountId: String, codecId: Long): Map<String, String> {
        return JamiService.getCodecDetails(accountId, codecId).toNative()
    }

    // ==================== Push Notifications ====================

    actual fun setPushNotificationToken(token: String) {
        JamiService.setPushNotificationToken(token)
    }

    actual fun setPushNotificationConfig(config: Map<String, String>) {
        JamiService.setPushNotificationConfig(StringMap.toSwig(config))
    }

    actual fun pushNotificationReceived(from: String, data: Map<String, String>) {
        JamiService.pushNotificationReceived(from, StringMap.toSwig(data))
    }

    // ==================== Callback Factory Methods ====================

    private fun createConfigurationCallback(callbacks: DaemonCallbacks) = object : ConfigurationCallback() {
        override fun accountsChanged() {
            callbacks.onAccountsChanged()
        }

        override fun accountDetailsChanged(accountId: String, details: StringMap) {
            callbacks.onAccountDetailsChanged(accountId, details.toNative())
        }

        override fun registrationStateChanged(accountId: String, state: String, code: Int, detail: String) {
            callbacks.onRegistrationStateChanged(accountId, state, code, detail)
        }

        override fun volatileAccountDetailsChanged(accountId: String, details: StringMap) {
            callbacks.onVolatileAccountDetailsChanged(accountId, details.toNative())
        }

        override fun knownDevicesChanged(accountId: String, devices: StringMap) {
            callbacks.onKnownDevicesChanged(accountId, devices.toNativeFromUtf8())
        }

        override fun nameRegistrationEnded(accountId: String, state: Int, name: String) {
            callbacks.onNameRegistrationEnded(accountId, state, name)
        }

        // Note: SWIG signature is (accountId, query, state, address, name)
        override fun registeredNameFound(accountId: String, query: String, state: Int, address: String, name: String) {
            callbacks.onRegisteredNameFound(accountId, state, address, name)
        }

        // Note: SWIG uses Blob for payload, we convert to ByteArray
        override fun incomingTrustRequest(accountId: String, conversationId: String, from: String, payload: Blob, received: Long) {
            callbacks.onIncomingTrustRequest(accountId, conversationId, from, payload.bytes, received)
        }

        override fun contactAdded(accountId: String, uri: String, confirmed: Boolean) {
            callbacks.onContactAdded(accountId, uri, confirmed)
        }

        override fun contactRemoved(accountId: String, uri: String, banned: Boolean) {
            callbacks.onContactRemoved(accountId, uri, banned)
        }

        override fun deviceRevocationEnded(accountId: String, deviceId: String, state: Int) {
            callbacks.onDeviceRevocationEnded(accountId, deviceId, state)
        }

        override fun migrationEnded(accountId: String, state: String) {
            callbacks.onMigrationEnded(accountId, state)
        }

        override fun accountProfileReceived(accountId: String, name: String, photo: String) {
            callbacks.onAccountProfileReceived(accountId, name, photo)
        }

        override fun profileReceived(accountId: String, peerId: String, vcardPath: String) {
            callbacks.onProfileReceived(accountId, peerId, vcardPath)
        }

        override fun incomingAccountMessage(accountId: String, messageId: String, from: String, messages: StringMap) {
            callbacks.onIncomingAccountMessage(accountId, messageId, null, from, messages.toNative())
        }

        override fun accountMessageStatusChanged(accountId: String, conversationId: String, peer: String, messageId: String, status: Int) {
            callbacks.onAccountMessageStatusChanged(accountId, conversationId, messageId, peer, status)
        }

        override fun composingStatusChanged(accountId: String, conversationId: String, contactUri: String, status: Int) {
            callbacks.onComposingStatusChanged(accountId, conversationId, contactUri, status)
        }

        override fun userSearchEnded(accountId: String, state: Int, query: String, results: VectMap) {
            callbacks.onUserSearchEnded(accountId, state, query, results.toNative())
        }
    }

    private fun createCallCallback(callbacks: DaemonCallbacks) = object : Callback() {
        override fun callStateChanged(accountId: String, callId: String, state: String, code: Int) {
            callbacks.onCallStateChanged(accountId, callId, state, code)
        }

        // Note: SWIG signature includes mediaList as 4th parameter
        override fun incomingCall(accountId: String, callId: String, from: String, mediaList: VectMap) {
            callbacks.onIncomingCall(accountId, callId, from)
            callbacks.onMediaChangeRequested(accountId, callId, mediaList.toNative())
        }

        override fun mediaChangeRequested(accountId: String, callId: String, mediaList: VectMap) {
            callbacks.onMediaChangeRequested(accountId, callId, mediaList.toNative())
        }

        override fun conferenceCreated(accountId: String, conversationId: String, confId: String) {
            callbacks.onConferenceCreated(accountId, conversationId, confId)
        }

        override fun conferenceChanged(accountId: String, confId: String, state: String) {
            callbacks.onConferenceChanged(accountId, confId, state)
        }

        override fun conferenceRemoved(accountId: String, confId: String) {
            callbacks.onConferenceRemoved(accountId, confId)
        }
    }

    private fun createPresenceCallback(callbacks: DaemonCallbacks) = object : PresenceCallback() {
        override fun newBuddyNotification(accountId: String, buddyUri: String, status: Int, lineStatus: String) {
            // Presence updates - can be extended if needed
        }
    }

    private fun createVideoCallback() = object : VideoCallback() {
        override fun getCameraInfo(camId: String, formats: net.jami.daemon.IntVect, sizes: net.jami.daemon.UintVect, rates: net.jami.daemon.UintVect) {
            // Camera info - platform specific implementation needed
        }

        override fun startCapture(camId: String) {
            // Start camera capture - platform specific
        }

        override fun stopCapture(camId: String) {
            // Stop camera capture - platform specific
        }
    }

    private fun createDataTransferCallback(callbacks: DaemonCallbacks) = object : DataTransferCallback() {
        override fun dataTransferEvent(accountId: String, conversationId: String, interactionId: String, fileId: String, eventCode: Int) {
            callbacks.onDataTransferEvent(accountId, conversationId, interactionId, fileId, eventCode)
        }
    }

    private fun createConversationCallback(callbacks: DaemonCallbacks) = object : ConversationCallback() {
        override fun conversationReady(accountId: String, conversationId: String) {
            callbacks.onConversationReady(accountId, conversationId)
        }

        override fun conversationRemoved(accountId: String, conversationId: String) {
            callbacks.onConversationRemoved(accountId, conversationId)
        }

        override fun conversationRequestReceived(accountId: String, conversationId: String, metadata: StringMap) {
            callbacks.onConversationRequestReceived(accountId, conversationId, metadata.toNativeFromUtf8())
        }

        override fun conversationMemberEvent(accountId: String, conversationId: String, uri: String, event: Int) {
            callbacks.onConversationMemberEvent(accountId, conversationId, uri, event)
        }

        override fun swarmMessageReceived(accountId: String, conversationId: String, message: SwigSwarmMessage) {
            callbacks.onMessageReceived(accountId, conversationId, message.toKotlinSwarmMessage())
        }

        override fun conversationProfileUpdated(accountId: String, conversationId: String, profile: StringMap) {
            callbacks.onConversationProfileUpdated(accountId, conversationId, profile.toNativeFromUtf8())
        }

        override fun messagesFound(id: Long, accountId: String, conversationId: String, messages: VectMap) {
            callbacks.onMessagesFound(id.toInt(), accountId, conversationId, messages.toNative())
        }

        override fun swarmLoaded(id: Long, accountId: String, conversationId: String, messages: net.jami.daemon.SwarmMessageVect) {
            val swarmMessages = (0 until messages.size.toInt()).map { messages[it].toKotlinSwarmMessage() }
            callbacks.onSwarmLoaded(id, accountId, conversationId, swarmMessages)
        }

        override fun swarmMessageUpdated(accountId: String, conversationId: String, message: SwigSwarmMessage) {
            callbacks.onMessageUpdated(accountId, conversationId, message.toKotlinSwarmMessage())
        }

        override fun reactionAdded(accountId: String, conversationId: String, messageId: String, reaction: StringMap) {
            callbacks.onReactionAdded(accountId, conversationId, messageId, reaction.toNative())
        }

        override fun reactionRemoved(accountId: String, conversationId: String, messageId: String, reactionId: String) {
            callbacks.onReactionRemoved(accountId, conversationId, messageId, reactionId)
        }

        override fun conversationRequestDeclined(accountId: String, conversationId: String) {
            callbacks.onConversationRequestDeclined(accountId, conversationId)
        }

        override fun conversationPreferencesUpdated(accountId: String, conversationId: String, preferences: StringMap) {
            callbacks.onConversationPreferencesUpdated(accountId, conversationId, preferences.toNative())
        }
    }
}

// ==================== Extension Functions ====================

/**
 * Convert SWIG SwarmMessage to Kotlin SwarmMessage.
 */
private fun SwigSwarmMessage.toKotlinSwarmMessage(): SwarmMessage {
    // Convert reactions VectMap to Map<String, List<String>>
    val reactionsMap = mutableMapOf<String, List<String>>()
    reactions?.let { rxns ->
        for (i in 0 until rxns.size) {
            val reactionMap = rxns[i].toNative()
            val msgId = reactionMap["id"] ?: continue
            val emoji = reactionMap["body"] ?: continue
            reactionsMap[msgId] = (reactionsMap[msgId] ?: emptyList()) + emoji
        }
    }

    // Convert status IntegerMap to Map<String, Int>
    val statusMap = mutableMapOf<String, Int>()
    status?.let { st ->
        for ((key, value) in st.entries) {
            statusMap[key] = value
        }
    }

    return SwarmMessage(
        id = id ?: "",
        type = type ?: "",
        linearizedParent = linearizedParent ?: "",
        body = body?.toNativeFromUtf8() ?: emptyMap(),
        reactions = reactionsMap,
        editions = editions?.toNative() ?: emptyList(),
        status = statusMap
    )
}

/**
 * Convert MediaAttribute list to SWIG VectMap.
 */
private fun List<MediaAttribute>.toSwigVectMap(): VectMap {
    val vectMap = VectMap()
    forEach { attr ->
        val map = StringMap()
        map["MEDIA_TYPE"] = when (attr.mediaType) {
            MediaAttribute.MediaType.AUDIO -> "MEDIA_TYPE_AUDIO"
            MediaAttribute.MediaType.VIDEO -> "MEDIA_TYPE_VIDEO"
        }
        map["ENABLED"] = attr.enabled.toString()
        map["MUTED"] = attr.muted.toString()
        map["SOURCE"] = attr.source
        map["LABEL"] = attr.label
        vectMap.add(map)
    }
    return vectMap
}

/**
 * Convert List<Map<String, String>> to SWIG VectMap.
 */
@JvmName("toSwigVectMapFromMapList")
private fun List<Map<String, String>>.toSwigVectMap(): VectMap {
    val vectMap = VectMap()
    forEach { entry ->
        val map = StringMap()
        entry.forEach { (k, v) -> map[k] = v }
        vectMap.add(map)
    }
    return vectMap
}
