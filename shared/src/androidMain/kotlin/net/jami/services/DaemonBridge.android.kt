/*
 *  Copyright (C) 2004-2025 Savoir-faire Linux Inc.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program. If not, see <https://www.gnu.org/licenses/>.
 */
package net.jami.services

import net.jami.model.MediaAttribute
import net.jami.model.SwarmMessage
import net.jami.utils.Log

/**
 * Android implementation of DaemonBridge using SWIG-generated JNI bindings.
 *
 * This implementation wraps the JamiService class generated by SWIG from
 * jami-daemon/bin/jni/jni_interface.i
 *
 * ## Integration Requirements
 *
 * To use this implementation, you need:
 * 1. Build libjami native library for Android (ARM64, ARM, x86_64, x86)
 * 2. Generate SWIG bindings by running make-swig.sh
 * 3. Include the generated Java files from net.jami.daemon package
 * 4. Load the native library: System.loadLibrary("jami")
 *
 * ## SWIG Classes Used
 *
 * The following SWIG-generated classes are required (in net.jami.daemon package):
 * - JamiService: Main service with static native methods
 * - Callback: Director class for call/conference events
 * - ConfigurationCallback: Director class for account/configuration events
 * - PresenceCallback: Director class for presence events
 * - VideoCallback: Director class for video/camera events
 * - DataTransferCallback: Director class for file transfer events
 * - ConversationCallback: Director class for conversation/messaging events
 * - StringMap, StringVect, VectMap, etc.: SWIG container types
 *
 * ## Callback Flow
 *
 * C++ Daemon → SWIG Director Classes → DaemonCallbackHandler → DaemonCallbacks interface
 */
actual class DaemonBridge actual constructor() {
    private var isInitialized = false
    private var callbacks: DaemonCallbacks? = null

    // Callback implementations - must keep references to prevent GC
    private var configurationCallback: Any? = null
    private var callCallback: Any? = null
    private var presenceCallback: Any? = null
    private var videoCallback: Any? = null
    private var dataTransferCallback: Any? = null
    private var conversationCallback: Any? = null

    companion object {
        private const val TAG = "DaemonBridge"

        // Load native library
        init {
            try {
                System.loadLibrary("jami")
                Log.i(TAG, "Native library 'jami' loaded successfully")
            } catch (e: UnsatisfiedLinkError) {
                Log.e(TAG, "Failed to load native library 'jami'", e)
            }
        }
    }

    actual fun init(callbacks: DaemonCallbacks): Boolean {
        this.callbacks = callbacks

        try {
            // Create callback implementations that forward to DaemonCallbacks
            // These extend the SWIG-generated director classes

            /* TODO: Uncomment when SWIG bindings are integrated
            configurationCallback = object : ConfigurationCallback() {
                override fun accountsChanged() {
                    callbacks.onAccountsChanged()
                }

                override fun accountDetailsChanged(accountId: String, details: StringMap) {
                    callbacks.onAccountDetailsChanged(accountId, details.toNative())
                }

                override fun registrationStateChanged(accountId: String, state: String, code: Int, detail: String) {
                    callbacks.onRegistrationStateChanged(accountId, state, code, detail)
                }

                override fun volatileAccountDetailsChanged(accountId: String, details: StringMap) {
                    callbacks.onVolatileAccountDetailsChanged(accountId, details.toNative())
                }

                override fun knownDevicesChanged(accountId: String, devices: StringMap) {
                    callbacks.onKnownDevicesChanged(accountId, devices.toNativeFromUtf8())
                }

                override fun nameRegistrationEnded(accountId: String, state: Int, name: String) {
                    callbacks.onNameRegistrationEnded(accountId, state, name)
                }

                override fun registeredNameFound(accountId: String, query: String, state: Int, address: String, name: String) {
                    callbacks.onRegisteredNameFound(accountId, state, address, name)
                }

                // System info callbacks - platform specific
                override fun getHardwareAudioFormat(ret: IntVect) {
                    // Android-specific: return audio format info
                    ret.add(44100) // Sample rate
                    ret.add(16)    // Bit depth
                    ret.add(2)     // Channels
                }

                override fun getAppDataPath(name: String, ret: StringVect) {
                    // Android-specific: return app data path
                    // ret.add(context.filesDir.absolutePath)
                }

                override fun getDeviceName(ret: StringVect) {
                    ret.add(android.os.Build.MODEL)
                }
            }

            callCallback = object : Callback() {
                override fun callStateChanged(accountId: String, callId: String, state: String, code: Int) {
                    callbacks.onCallStateChanged(accountId, callId, state, code)
                }

                override fun incomingCall(accountId: String, callId: String, from: String, mediaList: VectMap) {
                    callbacks.onIncomingCall(accountId, callId, from, mediaList.toNative())
                }

                override fun mediaChangeRequested(accountId: String, callId: String, mediaList: VectMap) {
                    callbacks.onMediaChangeRequested(accountId, callId, mediaList.toNative())
                }

                override fun conferenceCreated(accountId: String, conversationId: String, confId: String) {
                    callbacks.onConferenceCreated(accountId, conversationId, confId)
                }

                override fun conferenceChanged(accountId: String, confId: String, state: String) {
                    callbacks.onConferenceChanged(accountId, confId, state)
                }

                override fun conferenceRemoved(accountId: String, confId: String) {
                    callbacks.onConferenceRemoved(accountId, confId)
                }
            }

            presenceCallback = object : PresenceCallback() {
                override fun newBuddyNotification(accountId: String, buddyUri: String, status: Int, lineStatus: String) {
                    // Handle presence updates
                }
            }

            videoCallback = object : VideoCallback() {
                override fun getCameraInfo(camId: String, formats: IntVect, sizes: UintVect, rates: UintVect) {
                    // Android-specific camera info
                }

                override fun startCapture(camId: String) {
                    // Start Android camera capture
                }

                override fun stopCapture(camId: String) {
                    // Stop Android camera capture
                }
            }

            dataTransferCallback = object : DataTransferCallback() {
                override fun dataTransferEvent(accountId: String, conversationId: String, interactionId: String, fileId: String, eventCode: Int) {
                    // Handle file transfer events
                }
            }

            conversationCallback = object : ConversationCallback() {
                override fun conversationReady(accountId: String, conversationId: String) {
                    callbacks.onConversationReady(accountId, conversationId)
                }

                override fun conversationRemoved(accountId: String, conversationId: String) {
                    callbacks.onConversationRemoved(accountId, conversationId)
                }

                override fun conversationRequestReceived(accountId: String, conversationId: String, metadata: StringMap) {
                    callbacks.onConversationRequestReceived(accountId, conversationId, metadata.toNativeFromUtf8())
                }

                override fun conversationMemberEvent(accountId: String, conversationId: String, uri: String, event: Int) {
                    callbacks.onConversationMemberEvent(accountId, conversationId, uri, event)
                }

                override fun swarmMessageReceived(accountId: String, conversationId: String, message: SwarmMessage) {
                    callbacks.onMessageReceived(accountId, conversationId, message.toKotlinSwarmMessage())
                }

                override fun conversationProfileUpdated(accountId: String, conversationId: String, profile: StringMap) {
                    callbacks.onConversationProfileUpdated(accountId, conversationId, profile.toNativeFromUtf8())
                }
            }

            // Initialize daemon with all callbacks
            JamiService.init(
                configurationCallback as ConfigurationCallback,
                callCallback as Callback,
                presenceCallback as PresenceCallback,
                dataTransferCallback as DataTransferCallback,
                videoCallback as VideoCallback,
                conversationCallback as ConversationCallback
            )
            */

            isInitialized = true
            Log.i(TAG, "DaemonBridge initialized")
            return true

        } catch (e: Exception) {
            Log.e(TAG, "Failed to initialize daemon", e)
            return false
        }
    }

    actual fun start(): Boolean {
        if (!isInitialized) {
            Log.w(TAG, "Cannot start - daemon not initialized")
            return false
        }
        // JamiService starts automatically on init
        Log.i(TAG, "Daemon started")
        return true
    }

    actual fun stop() {
        if (isInitialized) {
            // TODO: JamiService.fini()
            isInitialized = false
            Log.i(TAG, "Daemon stopped")
        }
    }

    actual fun isRunning(): Boolean = isInitialized

    // ==================== Account Operations ====================

    actual fun addAccount(details: Map<String, String>): String {
        // TODO: return JamiService.addAccount(StringMap.toSwig(details))
        return ""
    }

    actual fun removeAccount(accountId: String) {
        // TODO: JamiService.removeAccount(accountId)
    }

    actual fun getAccountDetails(accountId: String): Map<String, String> {
        // TODO: return JamiService.getAccountDetails(accountId).toNative()
        return emptyMap()
    }

    actual fun setAccountDetails(accountId: String, details: Map<String, String>) {
        // TODO: JamiService.setAccountDetails(accountId, StringMap.toSwig(details))
    }

    actual fun getAccountList(): List<String> {
        // TODO: return JamiService.getAccountList().toList()
        return emptyList()
    }

    actual fun setAccountActive(accountId: String, active: Boolean) {
        // TODO: JamiService.setAccountActive(accountId, active)
    }

    // ==================== Call Operations ====================

    actual fun placeCall(accountId: String, uri: String, mediaList: List<MediaAttribute>): String {
        // TODO: Convert mediaList to SWIG VectMap
        // val swigMedia = VectMap()
        // mediaList.forEach { attr ->
        //     val map = StringMap()
        //     map["MEDIA_TYPE"] = attr.mediaType.name
        //     map["ENABLED"] = attr.enabled.toString()
        //     map["MUTED"] = attr.muted.toString()
        //     map["SOURCE"] = attr.source
        //     map["LABEL"] = attr.label
        //     swigMedia.add(map)
        // }
        // return JamiService.placeCallWithMedia(accountId, uri, swigMedia)
        return ""
    }

    actual fun accept(accountId: String, callId: String, mediaList: List<MediaAttribute>) {
        // TODO: JamiService.acceptWithMedia(accountId, callId, mediaList.toSwigVectMap())
    }

    actual fun hangUp(accountId: String, callId: String) {
        // TODO: JamiService.hangUp(accountId, callId)
    }

    actual fun hold(accountId: String, callId: String) {
        // TODO: JamiService.hold(accountId, callId)
    }

    actual fun unhold(accountId: String, callId: String) {
        // TODO: JamiService.unhold(accountId, callId)
    }

    actual fun muteLocalMedia(accountId: String, callId: String, mediaType: String, mute: Boolean) {
        // TODO: JamiService.muteLocalMedia(accountId, callId, mediaType, mute)
    }

    // ==================== Conversation Operations ====================

    actual fun getConversations(accountId: String): List<String> {
        // TODO: return JamiService.getConversations(accountId).toList()
        return emptyList()
    }

    actual fun startConversation(accountId: String): String {
        // TODO: return JamiService.startConversation(accountId)
        return ""
    }

    actual fun sendMessage(accountId: String, conversationId: String, message: String, replyTo: String, flag: Int) {
        // TODO: JamiService.sendMessage(accountId, conversationId, message, replyTo, flag)
    }

    actual fun loadConversation(accountId: String, conversationId: String, fromMessage: String, size: Int) {
        // TODO: JamiService.loadConversation(accountId, conversationId, fromMessage, size)
    }

    actual fun getConversationMembers(accountId: String, conversationId: String): List<Map<String, String>> {
        // TODO: return JamiService.getConversationMembers(accountId, conversationId).toNative()
        return emptyList()
    }

    // ==================== Contact Operations ====================

    actual fun addContact(accountId: String, uri: String) {
        // TODO: JamiService.addContact(accountId, uri)
    }

    actual fun removeContact(accountId: String, uri: String, ban: Boolean) {
        // TODO: JamiService.removeContact(accountId, uri, ban)
    }

    actual fun getContacts(accountId: String): List<Map<String, String>> {
        // TODO: return JamiService.getContacts(accountId).toNative()
        return emptyList()
    }

    // ==================== Name Lookup ====================

    actual fun lookupName(accountId: String, nameServiceUrl: String, name: String): Boolean {
        // TODO: return JamiService.lookupName(accountId, nameServiceUrl, name)
        return false
    }

    actual fun lookupAddress(accountId: String, nameServiceUrl: String, address: String): Boolean {
        // TODO: return JamiService.lookupAddress(accountId, nameServiceUrl, address)
        return false
    }

    actual fun registerName(accountId: String, name: String, scheme: String, password: String): Boolean {
        // TODO: return JamiService.registerName(accountId, name, scheme, password)
        return false
    }

    // ==================== Messaging ====================

    actual fun sendTextMessage(accountId: String, callIdOrUri: String, message: String) {
        // TODO: JamiService.sendAccountTextMessage(accountId, callIdOrUri, StringMap.toSwig(mapOf("text/plain" to message)))
    }

    actual fun setIsComposing(accountId: String, uri: String, isComposing: Boolean) {
        // TODO: JamiService.setIsComposing(accountId, uri, isComposing)
    }

    actual fun cancelMessage(accountId: String, messageId: Long): Boolean {
        // TODO: return JamiService.cancelMessage(accountId, messageId)
        return false
    }
}

// ==================== SWIG Extension Functions ====================

/**
 * Extension functions for converting between SWIG types and Kotlin types.
 * These will be implemented when SWIG bindings are integrated.
 */

/*
// Convert SWIG StringMap to Kotlin Map
fun StringMap.toNative(): Map<String, String> {
    val result = HashMap<String, String>()
    val keys = keys()
    for (i in 0 until keys.size.toInt()) {
        val key = keys[i]
        result[key] = get(key)
    }
    return result
}

// Convert SWIG StringMap to Kotlin Map with UTF-8 decoding
fun StringMap.toNativeFromUtf8(): Map<String, String> {
    val result = HashMap<String, String>()
    val keys = keys()
    for (i in 0 until keys.size.toInt()) {
        val key = keys[i]
        result[key] = String(get(key).toByteArray(Charsets.ISO_8859_1), Charsets.UTF_8)
    }
    return result
}

// Convert Kotlin Map to SWIG StringMap
fun Map<String, String>.toSwig(): StringMap {
    val map = StringMap()
    forEach { (k, v) -> map[k] = v }
    return map
}

// Convert SWIG VectMap to Kotlin List<Map>
fun VectMap.toNative(): List<Map<String, String>> {
    val result = ArrayList<Map<String, String>>(size.toInt())
    for (i in 0 until size.toInt()) {
        result.add(get(i).toNative())
    }
    return result
}

// Convert SWIG StringVect to Kotlin List
fun StringVect.toList(): List<String> {
    val result = ArrayList<String>(size.toInt())
    for (i in 0 until size.toInt()) {
        result.add(get(i))
    }
    return result
}

// Convert SWIG SwarmMessage to Kotlin SwarmMessage
fun net.jami.daemon.SwarmMessage.toKotlinSwarmMessage(): net.jami.model.SwarmMessage {
    return net.jami.model.SwarmMessage(
        id = id,
        type = type,
        linearizedParent = linearizedParent,
        body = body.toNativeFromUtf8(),
        reactions = reactions.toNative(),
        editions = editions.toNative(),
        status = status.toNative()
    )
}

// Convert MediaAttribute list to SWIG VectMap
fun List<MediaAttribute>.toSwigVectMap(): VectMap {
    val vectMap = VectMap()
    forEach { attr ->
        val map = StringMap()
        map["MEDIA_TYPE"] = when (attr.mediaType) {
            MediaAttribute.MediaType.AUDIO -> "MEDIA_TYPE_AUDIO"
            MediaAttribute.MediaType.VIDEO -> "MEDIA_TYPE_VIDEO"
        }
        map["ENABLED"] = attr.enabled.toString()
        map["MUTED"] = attr.muted.toString()
        map["SOURCE"] = attr.source
        map["LABEL"] = attr.label
        vectMap.add(map)
    }
    return vectMap
}
*/
